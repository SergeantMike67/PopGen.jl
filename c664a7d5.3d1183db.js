(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{140:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return o})),t.d(a,"metadata",(function(){return b})),t.d(a,"rightToc",(function(){return c})),t.d(a,"default",(function(){return r}));var n=t(2),l=t(6),i=(t(0),t(150)),o={id:"api",title:"API",sidebar_label:"API"},b={id:"api/api",title:"API",description:"This page contains the APIs, or Application Programming Interface, which are the entirety of all the functions/commands available in PopGen.jl. Unlike other sections of these docs, this page is intended to be technical rather than a guide. Included here are the function definitions and their docstrings as they appear inside this package. Most of these functions are used under-the-hood and not exported, meaning that if you want to use them, you will need to invoke them with PopGen.function. For example, if you wanted to use uniquealleles (which is not exported), you can do so with PopGen.uniquealleles() .",source:"@site/docs/api/API.md",permalink:"/PopGen.jl/docs/api/api",editUrl:"https://github.com/pdimens/popgen.jl/edit/documentation/docs/api/API.md",sidebar_label:"API",sidebar:"docs",previous:{title:"Relatedness (Kinship)",permalink:"/PopGen.jl/docs/analyses/relatedness"}},c=[{value:"AlleleFreq.jl",id:"allelefreqjl",children:[{value:"<code>alleles</code>",id:"alleles",children:[]},{value:"<code>unique_alleles</code>",id:"unique_alleles",children:[]},{value:"<code>allele_freq</code>",id:"allele_freq",children:[]},{value:"<code>allele_freq</code>",id:"allele_freq-1",children:[]},{value:"<code>allele_freq_vec</code>",id:"allele_freq_vec",children:[]},{value:"<code>geno_count_observed</code>",id:"geno_count_observed",children:[]},{value:"<code>geno_count_expected</code>",id:"geno_count_expected",children:[]},{value:"<code>geno_freq</code>",id:"geno_freq",children:[]},{value:"<code>geno_freq</code>",id:"geno_freq-1",children:[]},{value:"<code>geno_freq</code>",id:"geno_freq-2",children:[]},{value:"<code>geno_freq_expected</code>",id:"geno_freq_expected",children:[]}]},{value:"Datasets.jl",id:"datasetsjl",children:[{value:"<code>dataset</code>",id:"dataset",children:[]},{value:"<code>nancycats</code>",id:"nancycats",children:[]},{value:"<code>gulfsharks</code>",id:"gulfsharks",children:[]}]},{value:"HardyWeinberg.jl",id:"hardyweinbergjl",children:[{value:"<code>locus_chi_sq</code>",id:"locus_chi_sq",children:[]},{value:"<code>multitest_missing</code>",id:"multitest_missing",children:[]},{value:"<code>hwe_test</code>",id:"hwe_test",children:[]}]},{value:"Heterozygosity.jl",id:"heterozygosityjl",children:[{value:"<code>ishom</code>",id:"ishom",children:[]},{value:"<code>ishet</code>",id:"ishet",children:[]},{value:"<code>hetero_o</code>",id:"hetero_o",children:[]},{value:"<code>hetero_e</code>",id:"hetero_e",children:[]},{value:"<code>heterozygosity</code>",id:"heterozygosity",children:[]},{value:"<code>het_sample</code>",id:"het_sample",children:[]}]},{value:"Manipulate.jl",id:"manipulatejl",children:[{value:"<code>locations</code>",id:"locations",children:[]},{value:"<code>locations!</code>",id:"locations-1",children:[]},{value:"<code>locations!</code>",id:"locations-2",children:[]},{value:"<code>locations!</code>",id:"locations-3",children:[]},{value:"<code>locations!</code>",id:"locations-4",children:[]},{value:"<code>loci</code>",id:"loci",children:[]},{value:"<code>loci</code>",id:"loci-1",children:[]},{value:"<code>get_genotypes</code>",id:"get_genotypes",children:[]},{value:"<code>get_sample_genotypes</code>",id:"get_sample_genotypes",children:[]},{value:"<code>locus</code>",id:"locus",children:[]},{value:"<code>missing</code>",id:"missing",children:[]},{value:"<code>populations!</code>",id:"populations",children:[]},{value:"<code>populations!</code>",id:"populations-1",children:[]},{value:"<code>populations!</code>",id:"populations-2",children:[]},{value:"<code> populations!</code>",id:"populations-3",children:[]},{value:"<code>populations!</code>",id:"populations-4",children:[]},{value:"<code>reindex</code>",id:"reindex",children:[]},{value:"<code>exclude_loci</code>",id:"exclude_loci",children:[]},{value:"<code>exclude_samples</code>",id:"exclude_samples",children:[]}]},{value:"SummaryInfo.jl",id:"summaryinfojl",children:[{value:"<code>alele_table</code>",id:"alele_table",children:[]},{value:"<code>allele_avg</code>",id:"allele_avg",children:[]},{value:"<code>richness</code>",id:"richness",children:[]},{value:"<code>summary</code>",id:"summary",children:[]}]},{value:"Types.jl",id:"typesjl",children:[{value:"<code>PopObj</code>",id:"popobj",children:[]},{value:"<code>PopData</code>",id:"popdata",children:[]},{value:"<code>GenoType</code>",id:"genotype",children:[]},{value:"<code>GenoTypeArray</code>",id:"genotypearray",children:[]}]},{value:"Delimited.jl",id:"delimitedjl",children:[{value:"<code>delimited</code>",id:"delimited",children:[]}]},{value:"Genepop.jl",id:"genepopjl",children:[{value:"<code>genepop</code>",id:"genepop",children:[]}]},{value:"ioUtils.jl",id:"ioutilsjl",children:[{value:"<code>determine_marker</code>",id:"determine_marker",children:[]},{value:"<code>find_ploidy</code>",id:"find_ploidy",children:[]},{value:"<code>phase</code>",id:"phase",children:[]},{value:"<code>phase_dip</code>",id:"phase_dip",children:[]}]},{value:"Read.jl",id:"readjl",children:[{value:"<code>read_in</code>",id:"read_in",children:[]}]},{value:"VariantCall.jl",id:"variantcalljl",children:[{value:"<code>bcf</code>",id:"bcf",children:[]},{value:"<code>vcf</code>",id:"vcf",children:[]}]}],p={rightToc:c};function r(e){var a=e.components,t=Object(l.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},p,t,{components:a,mdxType:"MDXLayout"}),Object(i.b)("p",null,"This page contains the APIs, or ",Object(i.b)("strong",{parentName:"p"},"A"),"pplication ",Object(i.b)("strong",{parentName:"p"},"P"),"rogramming ",Object(i.b)("strong",{parentName:"p"},"I"),"nterface, which are the entirety of all the functions/commands available in PopGen.jl. Unlike other sections of these docs, this page is intended to be ",Object(i.b)("em",{parentName:"p"},"technical")," rather than a guide. Included here are the function definitions and their docstrings as they appear inside this package. Most of these functions are used under-the-hood and not exported, meaning that if you want to use them, you will need to invoke them with ",Object(i.b)("inlineCode",{parentName:"p"},"PopGen.function"),". For example, if you wanted to use ",Object(i.b)("inlineCode",{parentName:"p"},"unique_alleles")," (which is not exported), you can do so with ",Object(i.b)("inlineCode",{parentName:"p"},"PopGen.unique_alleles()")," . "),Object(i.b)("h2",{id:"allelefreqjl"},"AlleleFreq.jl"),Object(i.b)("p",null,":::: tabs\n::: tab AlleleFreq.jl/alleles"),Object(i.b)("h3",{id:"alleles"},Object(i.b)("inlineCode",{parentName:"h3"},"alleles")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"alleles(locus::T) where T<:GenotypeArray\n")),Object(i.b)("p",null,"Return an array of all the non-missing alleles present in a locus.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab AlleleFreq.jl/unique_alleles"),Object(i.b)("h3",{id:"unique_alleles"},Object(i.b)("inlineCode",{parentName:"h3"},"unique_alleles")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"unique_alleles(locus::T) where T<:GenotypeArray\n")),Object(i.b)("p",null,"Return an array of all the unique non-missing alleles of a locus.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab AlleleFreq.jl/allele_freq"),Object(i.b)("h3",{id:"allele_freq"},Object(i.b)("inlineCode",{parentName:"h3"},"allele_freq")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"allele_freq(locus::T) where T<:GenotypeArray\n")),Object(i.b)("p",null,"Return a ",Object(i.b)("inlineCode",{parentName:"p"},"Dict")," of allele frequencies of a single locus in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),"\nobject.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab AlleleFreq.jl/allele_freq"),Object(i.b)("h3",{id:"allele_freq-1"},Object(i.b)("inlineCode",{parentName:"h3"},"allele_freq")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"allele_freq(data::PopData, locus::String; population::Bool = false)\n")),Object(i.b)("p",null,"Return a ",Object(i.b)("inlineCode",{parentName:"p"},"Dict")," of allele frequencies of a single locus in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),"\nobject. Use ",Object(i.b)("inlineCode",{parentName:"p"},"population = true")," to return a table of allele frequencies\nof that locus per population.\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'cats = nancycats()\nallele_freq(cats, "fca8")\nallele_freq(cats, "fca8", population = true)\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab AlleleFreq.jl/allele_feq_vec"),Object(i.b)("h3",{id:"allele_freq_vec"},Object(i.b)("inlineCode",{parentName:"h3"},"allele_freq_vec")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"allele_freq_vec(locus::T) where T<:GenotypeArray\n")),Object(i.b)("p",null,"Return a Vector of allele frequencies of a single locus in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. Similar to ",Object(i.b)("inlineCode",{parentName:"p"},"allele_freq()"),", except it returns only the frequencies, without the allele names, meaning they can be in any order. This can be useful for getting the expected genotype frequencies.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab AlleleFreq.jl/geno_count_observed"),Object(i.b)("h3",{id:"geno_count_observed"},Object(i.b)("inlineCode",{parentName:"h3"},"geno_count_observed")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"geno_count_observed(locus::T) where T<:GenotypeArray\n")),Object(i.b)("p",null,"Return a ",Object(i.b)("inlineCode",{parentName:"p"},"Dict")," of genotype counts of a single locus in a\n",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab AlleleFreq.jl/geno_count_expected"),Object(i.b)("h3",{id:"geno_count_expected"},Object(i.b)("inlineCode",{parentName:"h3"},"geno_count_expected")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"geno_count_expected(locus::T) where T<:GenotypeArray\n")),Object(i.b)("p",null,"Return a ",Object(i.b)("inlineCode",{parentName:"p"},"Dict")," of the expected genotype counts of a single locus in a\n",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. Expected counts are calculated as the product of observed allele frequencies multiplied by the number of non-missing genotypes.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab AlleleFreq.jl/geno_freq"),Object(i.b)("h3",{id:"geno_freq"},Object(i.b)("inlineCode",{parentName:"h3"},"geno_freq")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"geno_freq(locus::T) where T<:GenotypeArray\n`PopData` object.\n")),Object(i.b)("p",null,"Return a ",Object(i.b)("inlineCode",{parentName:"p"},"Dict")," of genotype frequencies of a single locus in a\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab AlleleFreq.jl/geno_freq"),Object(i.b)("h3",{id:"geno_freq-1"},Object(i.b)("inlineCode",{parentName:"h3"},"geno_freq")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"geno_freq(data::PopData, locus::String; population::Bool = false)\n")),Object(i.b)("p",null,"Return a ",Object(i.b)("inlineCode",{parentName:"p"},"Dict")," of genotype frequencies of a single locus in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),"\nobject. Use ",Object(i.b)("inlineCode",{parentName:"p"},"population = true")," to return a table of genotype frequencies\nof that locus per population.\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'cats = nancycats()\ngeno_freq(cats, "fca8")\ngeno_freq(cats, "fca8", population = true)\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab AlleleFreq.jl/geno_freq"),Object(i.b)("h3",{id:"geno_freq-2"},Object(i.b)("inlineCode",{parentName:"h3"},"geno_freq")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"geno_freq_expected(locus::T) where T<:GenotypeArray\n")),Object(i.b)("p",null,"Return a ",Object(i.b)("inlineCode",{parentName:"p"},"Dict")," of the expected genotype frequencies of a single locus in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. Expected frequencies are calculated as the product of\nobserved allele frequencies.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab AlleleFreq.jl/geno_freq_expected"),Object(i.b)("h3",{id:"geno_freq_expected"},Object(i.b)("inlineCode",{parentName:"h3"},"geno_freq_expected")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"geno_freq_expected(data::PopData, locus::String; population::Bool = false)\n")),Object(i.b)("p",null,"Return a ",Object(i.b)("inlineCode",{parentName:"p"},"Dict")," of expected genotype frequencies of a single locus in a\n",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. Use ",Object(i.b)("inlineCode",{parentName:"p"},"population = true")," to return a table of expected genotype frequencies of that locus per population.\n:::\n::: example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'cats = nancycats()\ngeno_freq_expeced(cats, "fca8")\ngeno_freq_expected(cats, "fca8", population = true)\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("h2",{id:"datasetsjl"},"Datasets.jl"),Object(i.b)("p",null,":::: tabs\n::: tab Datasets.jl/dataset"),Object(i.b)("h3",{id:"dataset"},Object(i.b)("inlineCode",{parentName:"h3"},"dataset")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"dataset(::String)\n")),Object(i.b)("p",null,"Load an example dataset from either ",Object(i.b)("inlineCode",{parentName:"p"},'"gulfsharks"')," (SNP) or ",Object(i.b)("inlineCode",{parentName:"p"},'"nancycats"')," (microsatellite). Can also use ",Object(i.b)("inlineCode",{parentName:"p"},'"sharks"')," and ",Object(i.b)("inlineCode",{parentName:"p"},'"cats"'),"\nas shorthands. Use ",Object(i.b)("inlineCode",{parentName:"p"},"?nancycats")," and ",Object(i.b)("inlineCode",{parentName:"p"},"?gulfsharks")," to learn more about\nthese datasets.\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'ncats = dataset("nancycats")\ngsharks = dataset("sharks")\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Datasets.jl/nancycats"),Object(i.b)("h3",{id:"nancycats"},Object(i.b)("inlineCode",{parentName:"h3"},"nancycats")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"nancycats()\n")),Object(i.b)("p",null,"Returns a ",Object(i.b)("inlineCode",{parentName:"p"},"PopObj"),' of corresponding "nancycats" dataset as featured in\nthe R package ',Object(i.b)("inlineCode",{parentName:"p"},"adegenet"),". This is microsatellite data of 9 loci in 237\nindividuals across 17 populations.\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"ncats = nancycats()\n")),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Datasets.jl/gulfsharks"),Object(i.b)("h3",{id:"gulfsharks"},Object(i.b)("inlineCode",{parentName:"h3"},"gulfsharks")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"gulfsharks()\n")),Object(i.b)("p",null,"Returns a ",Object(i.b)("inlineCode",{parentName:"p"},"PopObj")," corresponding the Blacknose shark dataset as used in\nDimens et al. 2019. This is a mid-sized SNP dataset of 2213 SNPs in 212\nindividuals, across 7 populations.\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"sharks = gulfsharks()\n")),Object(i.b)("p",null,":::\n::::"),Object(i.b)("h2",{id:"hardyweinbergjl"},"HardyWeinberg.jl"),Object(i.b)("p",null,":::: tabs\n::: tab HardyWeinberg.jl/locus_chi_sq"),Object(i.b)("h3",{id:"locus_chi_sq"},Object(i.b)("inlineCode",{parentName:"h3"},"locus_chi_sq")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"locus_chi_sq(locus::T) where T <: GenotypeArray\n")),Object(i.b)("p",null,"Calculate the chi square statistic and p-value for a locus\nReturns a tuple with chi-square statistic, degrees of freedom, and p-value.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab HardyWeinberg.jl/multitest_missing"),Object(i.b)("h3",{id:"multitest_missing"},Object(i.b)("inlineCode",{parentName:"h3"},"multitest_missing")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"    multitest_missing(pvals::Array{Float64,1}, correction::String)\n")),Object(i.b)("p",null,"Modification to ",Object(i.b)("inlineCode",{parentName:"p"},"MultipleTesting.adjust")," to include ",Object(i.b)("inlineCode",{parentName:"p"},"missing")," values in the returned array. Missing values are first removed from the array, the appropriate correction made, then missing values are re-added to the array at their original positions. See MultipleTesting.jl docs for full more detailed information.\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'multitest_missing([0.1, 0.01, 0.005, 0.3], "bh")\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab HardyWeinberg.jl/hwe_test"),Object(i.b)("h3",{id:"hwe_test"},Object(i.b)("inlineCode",{parentName:"h3"},"hwe_test")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'    hwe_test(data::PopData; by_pop::Bool = false; correction = "none")\n')),Object(i.b)("p",null,"Calculate chi-squared test of HWE for each locus and returns observed and\nexpected heterozygosity with chi-squared, degrees of freedom and p-values for each locus. Use ",Object(i.b)("inlineCode",{parentName:"p"},"by_pop = true")," to perform this separately for each population (default: by_pop = false) and return a NamedTuple of DataFrames with the names corresponding to the population names. Use ",Object(i.b)("inlineCode",{parentName:"p"},"correction =")," to specify a P-value adjustment method for multiple testing."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"correction methods (case insensitive)")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"bonferroni"')," : Bonferroni adjustment"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"holm"')," : Holm adjustment"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"hochberg"')," : Hochberg adjustment"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"bh"')," : Benjamini-Hochberg adjustment"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"by"')," : Benjamini-Yekutieli adjustment"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"bl"'),"  : Benjamini-Liu adjustment"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"hommel"')," : Hommel adjustment"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"sidak"')," : \u0160id\xe1k adjustment"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"forward stop"')," or ",Object(i.b)("inlineCode",{parentName:"li"},'"fs"')," : Forward-Stop adjustment"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"bc"')," : Barber-Cande\u0300s adjustment\n:::\n::: tab example")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'hwe_test(gulfsharks(), correction = "bh")\nhwe_test(gulfsharks(), by_pop = true, correction = "bh")\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("h2",{id:"heterozygosityjl"},"Heterozygosity.jl"),Object(i.b)("p",null,":::: tabs\n::: tab Heterozygosity.jl/ishom"),Object(i.b)("h3",{id:"ishom"},Object(i.b)("inlineCode",{parentName:"h3"},"ishom")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"ishom(locus::T) where T <: GenotypeArray\nishom(locus::Genotype)\nishom(locus::Missing)\n")),Object(i.b)("p",null,"A series of methods to test if a locus or loci are homozygous and return ",Object(i.b)("inlineCode",{parentName:"p"},"true")," if it is, ",Object(i.b)("inlineCode",{parentName:"p"},"false")," if it isn't, and ",Object(i.b)("inlineCode",{parentName:"p"},"missing")," if it's ",Object(i.b)("inlineCode",{parentName:"p"},"missing"),". The vector version simply broadcasts the function over the elements.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Heterozygosity.jl/ishet"),Object(i.b)("h3",{id:"ishet"},Object(i.b)("inlineCode",{parentName:"h3"},"ishet")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"ishet(locus::T) where T <: GenotypeArray\nishet(locus::Genotype)\nishet(locus::Missing)\n")),Object(i.b)("p",null,"A series of methods to test if a locus or loci are heterozygous and return ",Object(i.b)("inlineCode",{parentName:"p"},"true")," if it is, ",Object(i.b)("inlineCode",{parentName:"p"},"false")," if it isn't. The vector version simply broadcasts the function over the elements. Under the hood, this function is simply ",Object(i.b)("inlineCode",{parentName:"p"},"!ishom"),".\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Heterozygosity.jl/hetero_o"),Object(i.b)("h3",{id:"hetero_o"},Object(i.b)("inlineCode",{parentName:"h3"},"hetero_o")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"hetero_o(data::T) where T <: GenotypeArray\n")),Object(i.b)("p",null,"Returns observed heterozygosity as a mean of the number of heterozygous genotypes, defined as genotypes returning ",Object(i.b)("inlineCode",{parentName:"p"},"true")," for ",Object(i.b)("inlineCode",{parentName:"p"},"ishet()"),". This is numerically feasible because ",Object(i.b)("inlineCode",{parentName:"p"},"true")," values are mathematically represented as ",Object(i.b)("inlineCode",{parentName:"p"},"1"),", whereas ",Object(i.b)("inlineCode",{parentName:"p"},"false")," are represented as ",Object(i.b)("inlineCode",{parentName:"p"},"0"),".\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Heterozygosity.jl/hetero_e"),Object(i.b)("h3",{id:"hetero_e"},Object(i.b)("inlineCode",{parentName:"h3"},"hetero_e")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"hetero_e(allele_freqs::Vector{T}) where T <: GenotypeArray\n")),Object(i.b)("p",null,"Returns the expected heterozygosity of an array of genotypes, calculated as 1 - sum of the squared allele frequencies.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Heterozygosity.jl/heterozygosity"),Object(i.b)("h3",{id:"heterozygosity"},Object(i.b)("inlineCode",{parentName:"h3"},"heterozygosity")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'heterozygosity(data::PopData, mode::String = "locus")\n')),Object(i.b)("p",null,"Calculate observed and expected heterozygosity in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. For loci, heterozygosity is calculated in the Nei fashion, such that heterozygosity is calculated as the average over heterozygosity per locus per population."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Modes")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"locus"')," or ",Object(i.b)("inlineCode",{parentName:"li"},'"loci"')," : heterozygosity per locus (default)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"sample"')," or ",Object(i.b)("inlineCode",{parentName:"li"},'"ind"')," or ",Object(i.b)("inlineCode",{parentName:"li"},'"individual"')," : heterozygosity per individual/sample"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"population"')," or ",Object(i.b)("inlineCode",{parentName:"li"},'"pop"')," : heterozygosity per population\n:::\n::: tab example")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'heterozygosity(nancycats(), "population" )\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Heterozygosity.jl/het_sample"),Object(i.b)("h3",{id:"het_sample"},Object(i.b)("inlineCode",{parentName:"h3"},"het_sample")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"    het_sample(data::PopData, individual::String)\n")),Object(i.b)("p",null,"Calculate the observed heterozygosity for an individual in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. Returns an array of heterozygosity values.\n:::\n::::"),Object(i.b)("h2",{id:"manipulatejl"},"Manipulate.jl"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/locations"),Object(i.b)("h3",{id:"locations"},Object(i.b)("inlineCode",{parentName:"h3"},"locations")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"    locations(data::PopData)\n")),Object(i.b)("p",null,"View the longitude and latitude data in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. Returns a table derived from the PopData. Changes made to this table will not alter the source ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object."),Object(i.b)("p",null,"Use ",Object(i.b)("inlineCode",{parentName:"p"},"locations!")," to add spatial data to a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/locations!"),Object(i.b)("h3",{id:"locations-1"},Object(i.b)("inlineCode",{parentName:"h3"},"locations!")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"locations!(data::PopData; lat::Vector{Float64}, long::Vector{Float64})\nlocations!(data::PopData, lat::Vector{Union{Missing,T}}, long::Vector{Union{Missing,T}}) where T <: AbstractFloat\nlocations!(data::PopData, lat::Vector{T}, long::Vector{T}) where T <: AbstractFloat\n")),Object(i.b)("p",null,"Replaces existing ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," location data (latitude ",Object(i.b)("inlineCode",{parentName:"p"},"lat"),", longitude ",Object(i.b)("inlineCode",{parentName:"p"},"long"),").\nTakes decimal degrees as a ",Object(i.b)("inlineCode",{parentName:"p"},"Vector")," of any ",Object(i.b)("inlineCode",{parentName:"p"},"AbstractFloat"),"."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Formatting requirements")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Decimal Degrees format: ",Object(i.b)("inlineCode",{parentName:"li"},"-11.431")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Must")," use negative sign ",Object(i.b)("inlineCode",{parentName:"li"},"-")," instead of cardinal directions"),Object(i.b)("li",{parentName:"ul"},"Location data must be in the order that samples appear in your ",Object(i.b)("inlineCode",{parentName:"li"},"PopData")),Object(i.b)("li",{parentName:"ul"},"Missing data should be coded as ",Object(i.b)("inlineCode",{parentName:"li"},"missing")," values of type ",Object(i.b)("inlineCode",{parentName:"li"},"Missing")," (can be accomplished with ",Object(i.b)("inlineCode",{parentName:"li"},"replace!()"),")\n:::\n::: tab example")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"ncats = nancycats() ;\nx = rand(237) ; y = rand(237)\nlocations!(ncats, long = x, lat = y)\n")),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/locations"),Object(i.b)("h3",{id:"locations-2"},Object(i.b)("inlineCode",{parentName:"h3"},"locations!")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"locations!(data::PopData; lat::Vector{String}, long::Vector{String})\nlocations!(data::PopData, long::Vector{Union{Missing,String}}, lat::Vector{Union{Missing,String}})\n")),Object(i.b)("p",null,"Replaces existing ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," location data (latitude ",Object(i.b)("inlineCode",{parentName:"p"},"lat"),", longitude ",Object(i.b)("inlineCode",{parentName:"p"},"long"),"). Takes\ndecimal minutes format as a ",Object(i.b)("inlineCode",{parentName:"p"},"Vector")," of ",Object(i.b)("inlineCode",{parentName:"p"},"String"),". Recommended to use ",Object(i.b)("inlineCode",{parentName:"p"},"CSV.read"),"\nfrom ",Object(i.b)("inlineCode",{parentName:"p"},"CSV.jl")," to import your spatial coordinates from a text file."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Formatting requirements")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Decimal Minutes: ",Object(i.b)("inlineCode",{parentName:"li"},'"-11 43.11"')," (must use space and be a ",Object(i.b)("inlineCode",{parentName:"li"},"String"),")"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("strong",{parentName:"li"},"Must")," use negative sign ",Object(i.b)("inlineCode",{parentName:"li"},"-")," instead of cardinal directions"),Object(i.b)("li",{parentName:"ul"},"Location data must be in the order that samples appear in your ",Object(i.b)("inlineCode",{parentName:"li"},"PopData")),Object(i.b)("li",{parentName:"ul"},"Missing data should be coded as ",Object(i.b)("inlineCode",{parentName:"li"},"missing")," values of type ",Object(i.b)("inlineCode",{parentName:"li"},"Missing")," (can be accomplished with ",Object(i.b)("inlineCode",{parentName:"li"},"replace!()"),")\n:::\n::: tab example")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'ncats = nancycats();\nx = fill("-11 22.33", 237) ; y = fill("-41 31.52", 237)\nlocations!(ncats, long = x, lat = y)\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/locations!"),Object(i.b)("h3",{id:"locations-3"},Object(i.b)("inlineCode",{parentName:"h3"},"locations!")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"locations!(data::PopData; kwargs...)\n")),Object(i.b)("p",null,"Replaces existing ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," location data (latitude, longitude). Requires all four keyword arguments. Takes decimal minutes format as vectors of degrees (",Object(i.b)("inlineCode",{parentName:"p"},"Int"),") and decimal minutes (",Object(i.b)("inlineCode",{parentName:"p"},"Float"),"). Recommended to use ",Object(i.b)("inlineCode",{parentName:"p"},"CSV.read")," from ",Object(i.b)("inlineCode",{parentName:"p"},"CSV.jl")," to import your spatial coordinates from a text file."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Keyword Arguments:")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"lat_deg::Vector{Int}")," a vector of postive or negative integers denoting the latitude degrees"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"example: ",Object(i.b)("inlineCode",{parentName:"li"},"[11, -12, 15, 11]")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"lat_min::Vector{Float64}")," a vector of positive floating point numbers denoting the latitude decimal minutes"),Object(i.b)("ul",{parentName:"li"},Object(i.b)("li",{parentName:"ul"},"example: ",Object(i.b)("inlineCode",{parentName:"li"},"[43.12, 41.32, 36.53, 22.41]")))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"long_deg::Vector{Int}")," same as ",Object(i.b)("inlineCode",{parentName:"p"},"lat_deg")," but for longitude degrees")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("inlineCode",{parentName:"p"},"long_min::Vector{Float64}")," same as ",Object(i.b)("inlineCode",{parentName:"p"},"lat_min")," but for longitude minutes"),Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Formatting requirements"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},Object(i.b)("strong",{parentName:"p"},"Must")," use negative sign ",Object(i.b)("inlineCode",{parentName:"p"},"-")," instead of cardinal directions")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Location data must be in the order that samples appear in your ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"))),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Missing data should be coded as ",Object(i.b)("inlineCode",{parentName:"p"},"missing")," values of type ",Object(i.b)("inlineCode",{parentName:"p"},"Missing")," (can be accomplished with ",Object(i.b)("inlineCode",{parentName:"p"},"replace!()"),")\n:::\n::: tab example\nIf you have decimal-minutes coordinates for two samples:")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Sample 1  ",Object(i.b)("em",{parentName:"p"},"Long:")," 11 43.12  ",Object(i.b)("em",{parentName:"p"},"Lat:")," 15 36.53")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("p",{parentName:"li"},"Sample 2  ",Object(i.b)("em",{parentName:"p"},"Long:")," -12 41.32 ",Object(i.b)("em",{parentName:"p"},"Lat:")," 11 22.41"))),Object(i.b)("p",null,"Then your inputs would be:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"lo_deg = [11, -12]\nlo_min = [43.12, 41.32]\nla_deg  = [15, 11]\nla_min  = [36.53, 22.41]\nlocations!(data, long_deg = lo_deg, long_min = lo_min, lat_deg = la_deg, lat_min = la_min)\n")),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/locations!"),Object(i.b)("h3",{id:"locations-4"},Object(i.b)("inlineCode",{parentName:"h3"},"locations!")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"locations!(data::PopData,lat_deg::Vector{Union{Missing,Int}},lat_min::Vector{Union{Missing,Float64}},long_deg::Vector{Union{Missing,Int}},long_min::Vector{Union{Missing,Float64}})\n")),Object(i.b)("p",null,"Used internally for the appropriate processing of ",Object(i.b)("inlineCode",{parentName:"p"},"locations!(::PopData; kwargs...)"),"\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/loci"),Object(i.b)("h3",{id:"loci"},Object(i.b)("inlineCode",{parentName:"h3"},"loci")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"loci(data::PopData)\n")),Object(i.b)("p",null,"Returns an array of strings of the loci names in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/loci"),Object(i.b)("h3",{id:"loci-1"},Object(i.b)("inlineCode",{parentName:"h3"},"loci")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"loci(data::IndexedTable)\n")),Object(i.b)("p",null,"Convenience wrapper to return an array of loci names as strings in the ",Object(i.b)("inlineCode",{parentName:"p"},"loci"),"\nTable of a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/get_genotypes"),Object(i.b)("h3",{id:"get_genotypes"},Object(i.b)("inlineCode",{parentName:"h3"},"get_genotypes")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"get_genotypes(data::PopObj; samples::Union{String, Vector{String}}, loci::Union{String, Vector{String}})\n")),Object(i.b)("p",null,"Return the genotype(s) of one or more ",Object(i.b)("inlineCode",{parentName:"p"},"samples")," for one or more specific ",Object(i.b)("inlineCode",{parentName:"p"},"loci")," (both as keywords) in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object.\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'cats = nancycats();\nget_genotype(cats, samples = "N115" , loci = "fca8")\nget_genotypes(cats, samples = ["N1", "N2"] , loci = "fca8")\nget_genotype(cats, samples = "N115" , loci = ["fca8", "fca37"])\nget_genotype(cats, samples = ["N1", "N2"] , loci = ["fca8", "fca37"])\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/get_sample_genotypes"),Object(i.b)("h3",{id:"get_sample_genotypes"},Object(i.b)("inlineCode",{parentName:"h3"},"get_sample_genotypes")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"get_sample_genotypes(data::PopData, sample::String)\n")),Object(i.b)("p",null,"Return all the genotypes of a specific sample in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. This is an extension for the internal function ",Object(i.b)("inlineCode",{parentName:"p"},"get_genotypes"),".\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'cats = nancycats()\nget_sample_genotypes(cats, "N115")\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/locus"),Object(i.b)("h3",{id:"locus"},Object(i.b)("inlineCode",{parentName:"h3"},"locus")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"locus(data::PopData, locus::Union{String, Symbol})\n")),Object(i.b)("p",null,"Convenience wrapper to return a vector of all the genotypes of a single locus\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'locus(gulfsharks(), "contig_475")\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/missing"),Object(i.b)("h3",{id:"missing"},Object(i.b)("inlineCode",{parentName:"h3"},"missing")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'missing(data::PopData; mode::String = "sample")\n')),Object(i.b)("p",null,"Get missing genotype information in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),". Specify a mode of operation to return a DataFrame corresponding with that missing information."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Modes")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"sample"')," - returns a count and list of missing loci per individual (default)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"pop"')," - returns a count of missing genotypes per population"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"locus"')," - returns a count of missing genotypes per locus"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},'"full"')," - returns a count of missing genotypes per locus per population\n:::\n::: tab example")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'missing(gulfsharks(), mode = "pop")\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/populations"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"    populations(data::PopData; listall::Bool = false)\n")),Object(i.b)("p",null,"View unique population ID's and their counts in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),"."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"listall = true")," displays all samples and their ",Object(i.b)("inlineCode",{parentName:"li"},"population")," instead (default = ",Object(i.b)("inlineCode",{parentName:"li"},"false"),")\n:::\n::::")),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/populations!"),Object(i.b)("h3",{id:"populations"},Object(i.b)("inlineCode",{parentName:"h3"},"populations!")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"populations!(data::PopData, rename::Dict)\n")),Object(i.b)("p",null,"Rename existing population ID's of ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," using a ",Object(i.b)("inlineCode",{parentName:"p"},"Dict")," of\n",Object(i.b)("inlineCode",{parentName:"p"},"population_name => replacement"),"\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'potatopops = Dict("1" => "Idaho", "2" => "Russet")\npopulations!(potatoes, potatopops)\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/populations!"),Object(i.b)("h3",{id:"populations-1"},Object(i.b)("inlineCode",{parentName:"h3"},"populations!")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"populations!(data::PopData, rename::Vector{String})\n")),Object(i.b)("p",null,"Replace the current population names with a ",Object(i.b)("inlineCode",{parentName:"p"},"Vector")," of new unique population names in the order that they appear in the PopData.meta.\n:::\n::: tab  example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'potatopops = ["Idaho", "Russet"]\npopulations!(potatoes, potatopops)\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/populations!"),Object(i.b)("h3",{id:"populations-2"},Object(i.b)("inlineCode",{parentName:"h3"},"populations!")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"populations!(data::PopData, oldnames::Vector{String}, newnames::Vector{String})\n")),Object(i.b)("p",null,"Similar to the ",Object(i.b)("inlineCode",{parentName:"p"},"Dict"),' method, except instead of creating a dictionary of "oldname" => "newname" you input a Vector{String} of ',Object(i.b)("inlineCode",{parentName:"p"},"oldnames")," followed by another of ",Object(i.b)("inlineCode",{parentName:"p"},"newnames"),". Logically, the new names will replace the old names in the same order as they appear in PopData.meta(e.g. the first newname replaces the first oldname, etc.)."),Object(i.b)("p",null,":::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'populations!(potatoes, ["russet1", "russet2"], ["north_russet", "south_russet"])\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/populations!"),Object(i.b)("h3",{id:"populations-3"},Object(i.b)("inlineCode",{parentName:"h3"}," populations!")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"populations!(data::PopData, rename::NamedTuple)\n")),Object(i.b)("p",null,"Generate new population names for a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),", overwriting everthing/anything currently there. Will generate an array of population names from a NamedTuple of ",Object(i.b)("inlineCode",{parentName:"p"},"(names = , counts = )")," where ",Object(i.b)("inlineCode",{parentName:"p"},"names")," is an array of the names of the populations and ",Object(i.b)("inlineCode",{parentName:"p"},"counts")," is an array of the number of samples per population.\n:::\n::: tab example\nTo assign names for three populations in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),' named "Starlings" where new\npopulation names are "North", "South", "East" and their sizes are 15, 32, 11:'),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),'populations!(Starlings, (names = ["North","South", "East"], counts = [15,32,11]))\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/populations!"),Object(i.b)("h3",{id:"populations-4"},Object(i.b)("inlineCode",{parentName:"h3"},"populations!")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"populations!(data::PopData, rename::Vector{String}, counts::Vector{T}) where T<:Signed\n")),Object(i.b)("p",null,"Just like the NamedTuple method, except without the NamedTuple. Use an Array of Strings as the second argument to denote population names, and an Array of Integers as the third argument to denote the number of samples per population.\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'populations!(Starlings, ["North","South", "East"], [15,32,11])\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/reindex"),Object(i.b)("h3",{id:"reindex"},Object(i.b)("inlineCode",{parentName:"h3"},"reindex")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"reindex(data::PopData, col::Union{String, Symbol})\n")),Object(i.b)("p",null,"Re-index and sort the ",Object(i.b)("inlineCode",{parentName:"p"},"loci")," table of a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object by column ",Object(i.b)("inlineCode",{parentName:"p"},"col"),". Returns a new ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object.\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"sharks = gulfsharks()\nreindex(sharks, :population)\n")),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/exclude_loci"),Object(i.b)("h3",{id:"exclude_loci"},Object(i.b)("inlineCode",{parentName:"h3"},"exclude_loci")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"exclude_loci(data::PopData, locus::String)\nexclude_loci(data::PopData, loci::Vector{String})\n")),Object(i.b)("p",null,"Exclude selected loci from a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. Returns a new ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object,\nleaving the original intact. Synonymous with ",Object(i.b)("inlineCode",{parentName:"p"},"omit_loci")," and ",Object(i.b)("inlineCode",{parentName:"p"},"remove_loci"),".\n:::\n::: tab examples"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'new_cats = exclude_loci(nancycats(), "fca8")\nvery_new_cats = exclude_loci(nancycats(), ["fca8", "fca23"])\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/exclude_samples"),Object(i.b)("h3",{id:"exclude_samples"},Object(i.b)("inlineCode",{parentName:"h3"},"exclude_samples")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"exclude_samples(data::PopData, samp_id::String)\nexclude_samples(data::PopData, samp_id::Vector{String})\n")),Object(i.b)("p",null,"Exclude selected samples from a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. Returns a new ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object, leaving the original intact. Synonymous with ",Object(i.b)("inlineCode",{parentName:"p"},"omit_samples")," and ",Object(i.b)("inlineCode",{parentName:"p"},"remove_samples"),".\n:::\n::: tab examples"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'exclude_samples(nancycats, "N100")\nexclude_samples(nancycats, ["N100", "N102", "N211"])\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Manipulate.jl/samples"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"samples(data::PopData)\n")),Object(i.b)("p",null,"View individual/sample names in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),"\n:::\n::::"),Object(i.b)("h2",{id:"summaryinfojl"},"SummaryInfo.jl"),Object(i.b)("p",null,":::: tabs\n::: tab SummaryInfo.jl/allele_table"),Object(i.b)("h3",{id:"alele_table"},Object(i.b)("inlineCode",{parentName:"h3"},"alele_table")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"allele_table(data::PopData)\n")),Object(i.b)("p",null,'Return a "tidy" IndexedTable of the loci, their alleles, and their alleles\' frequencies.\n:::\n::::'),Object(i.b)("p",null,":::: tabs\n::: tab SummaryInfo.jl/allele_avg"),Object(i.b)("h3",{id:"allele_avg"},Object(i.b)("inlineCode",{parentName:"h3"},"allele_avg")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"    allele_avg(data::PopData, rounding::Bool = true)\n")),Object(i.b)("p",null,"Returns a NamedTuple of the average number of alleles ('mean') and standard deviation (",Object(i.b)("inlineCode",{parentName:"p"},"stdev"),") of a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),". Use ",Object(i.b)("inlineCode",{parentName:"p"},"rounding = false")," to not round results. Default (",Object(i.b)("inlineCode",{parentName:"p"},"true"),") roundsto 4 digits.\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"allele_avg(nancycats(), rounding = false)\n")),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab SummaryInfo.jl/richness"),Object(i.b)("h3",{id:"richness"},Object(i.b)("inlineCode",{parentName:"h3"},"richness")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"richness(data::PopData)\n")),Object(i.b)("p",null,"Calculates various allelic richness and returns a table of per-locus allelic richness. Use ",Object(i.b)("inlineCode",{parentName:"p"},"populations = true")," to calculate richness by locus by population.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab SummaryInfo.jl/summary"),Object(i.b)("h3",{id:"summary"},Object(i.b)("inlineCode",{parentName:"h3"},"summary")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"summary(data::PopData)\n")),Object(i.b)("p",null,"Prints a summary of the information contained in a PopData object\n:::\n::::"),Object(i.b)("h2",{id:"typesjl"},"Types.jl"),Object(i.b)("p",null,":::: tabs\n::: tab Types.jl/PopObj"),Object(i.b)("h3",{id:"popobj"},Object(i.b)("inlineCode",{parentName:"h3"},"PopObj")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-Julia"}),"PopObj\n")),Object(i.b)("p",null,"Generic AbstractType for use in PopGen.jl\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Types.jl/PopData"),Object(i.b)("h3",{id:"popdata"},Object(i.b)("inlineCode",{parentName:"h3"},"PopData")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"PopData(meta::IndexedTable, loci::IndexedTable)\n")),Object(i.b)("p",null,"The data struct used for the PopGen population genetics ecosystem. You are\n",Object(i.b)("strong",{parentName:"p"},"strongly")," discouraged from manually creating tables to pass into a PopObj,\nand instead should use the provided genepop, csv, or vcf file importers."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"meta")," ::IndexedTable")," individual/sample data with the columns:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"name")," ::String the individual/sample names"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"population")," ::String population names"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"ploidy")," ::Int8 ploidy in order of ",Object(i.b)("inlineCode",{parentName:"li"},"ind")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"longitude")," ::Float64 longitude values"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"latitude")," ::Float64 latitude values")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("inlineCode",{parentName:"strong"},"loci")," ::IndexedTable")," Long-format table of sample genotype records"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"name")," ::CategoricalString the individual/sample names"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"population"),"::CategoricalString population name"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"locus")," ::CategoricalString of locus name"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"genotype")," Tuple of Int8 or Int16 depending on SNP or microsatellite\n:::\n::::")),Object(i.b)("p",null,":::: tabs\n::: tab Types.jl/GenoType"),Object(i.b)("h3",{id:"genotype"},Object(i.b)("inlineCode",{parentName:"h3"},"GenoType")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"Genotype::DataType\n")),Object(i.b)("p",null,"For convenience purposes, an alias for ",Object(i.b)("inlineCode",{parentName:"p"},"NTuple{N, <:Signed} where N"),", which is the type describing individual genotypes in PopData.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab Types.jl/GenoTypeArray"),Object(i.b)("h3",{id:"genotypearray"},Object(i.b)("inlineCode",{parentName:"h3"},"GenoTypeArray")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"GenotypeArray::DataType\n")),Object(i.b)("p",null,"For convenience purposes, an alias for an ",Object(i.b)("inlineCode",{parentName:"p"},"AbstractVector")," of elements ",Object(i.b)("inlineCode",{parentName:"p"},"Missing")," and ",Object(i.b)("inlineCode",{parentName:"p"},"Genotype"),", which itself is of type ",Object(i.b)("inlineCode",{parentName:"p"},"NTuple{N, <:Signed} where N"),". The definition as an ",Object(i.b)("inlineCode",{parentName:"p"},"AbstractVector")," adds flexibility for ",Object(i.b)("inlineCode",{parentName:"p"},"SubArray")," cases.\n:::\n::::"),Object(i.b)("h2",{id:"delimitedjl"},"Delimited.jl"),Object(i.b)("p",null,":::: tabs\n::: tab Delimited.jl/delimited"),Object(i.b)("h3",{id:"delimited"},Object(i.b)("inlineCode",{parentName:"h3"},"delimited")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'delimited(infile::String; delim::Union{Char,String,Regex} = "auto", digits::Int64 = 3, silent::Bool = false)\n')),Object(i.b)("p",null,"Load a delimited-type file into memory as a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. ",Object(i.b)("em",{parentName:"p"},"There should be no empty cells\nin your file")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"infile")," : path to file"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"delim")," : delimiter characters. By default uses auto-parsing of ",Object(i.b)("inlineCode",{parentName:"li"},"CSV.File")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"digits")," : number of digits denoting each allele (default: ",Object(i.b)("inlineCode",{parentName:"li"},"3"),")"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"diploid"),"  : whether samples are diploid for parsing optimizations (default: ",Object(i.b)("inlineCode",{parentName:"li"},"true"),")"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"silent"),"   : whether to print file information during import (default: ",Object(i.b)("inlineCode",{parentName:"li"},"true"),")")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"File formatting:")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"First row is column names in this order:",Object(i.b)("ol",{parentName:"li"},Object(i.b)("li",{parentName:"ol"},"name"),Object(i.b)("li",{parentName:"ol"},"population"),Object(i.b)("li",{parentName:"ol"},"longitude"),Object(i.b)("li",{parentName:"ol"},"latitude"),Object(i.b)("li",{parentName:"ol"},"locus_1_name"),Object(i.b)("li",{parentName:"ol"},"locus_2_name"),Object(i.b)("li",{parentName:"ol"},"etc...")))),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Missing data - Genotypes")),Object(i.b)("p",null,"Missing genotypes can be formatted as all-zeros ",Object(i.b)("inlineCode",{parentName:"p"},"000000")," or negative-nine ",Object(i.b)("inlineCode",{parentName:"p"},"-9")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Missing data - Locations")),Object(i.b)("p",null,"If location data is missing for a sample (which is ok!), make sure the value is written\nas ",Object(i.b)("em",{parentName:"p"},"0"),", otherwise there will be transcription errors!"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Formatting example:")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"name,population,long,lat,Locus1,Locus2,Locus3\nsierra_01,mountain,11.11,-22.22,001001,002002,001001\nsierra_02,mountain,11.12,-22.21,001001,001001,001002\nsnbarb_03,coast,0,0,001001,001001,001002\nsnbarb_02,coast,11.14,-22.24,001001,001001,001001\nsnbarb_03,coast,11.15,0,001002,001001,001001\n")),Object(i.b)("p",null,":::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'lizardsCA = delimited("CA_lizards.csv", digits = 3);\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("h2",{id:"genepopjl"},"Genepop.jl"),Object(i.b)("p",null,":::: tabs\n::: tab Genepop.jl/genepop"),Object(i.b)("h3",{id:"genepop"},Object(i.b)("inlineCode",{parentName:"h3"},"genepop")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"genepop(infile::String; kwargs...)\n")),Object(i.b)("p",null,"Load a Genepop format file into memory as a PopData object."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"infile::String")," : path to Genepop file")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Keyword Arguments")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"digits::Integer"),": number of digits denoting each allele (default: ",Object(i.b)("inlineCode",{parentName:"li"},"3"),")"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"popsep::String")," : word that separates populations in ",Object(i.b)("inlineCode",{parentName:"li"},"infile"),' (default: "POP")'),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"diploid::Bool"),"  : whether samples are diploid for parsing optimizations (default: ",Object(i.b)("inlineCode",{parentName:"li"},"true"),")"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"silent::Bool"),"   : whether to print file information during import (default: ",Object(i.b)("inlineCode",{parentName:"li"},"true"),")")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"File must follow standard Genepop formatting")),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"First line is a comment (and skipped)"),Object(i.b)("li",{parentName:"ul"},"Loci are listed after first line as one-per-line without commas or in single comma-separated row"),Object(i.b)("li",{parentName:"ul"},"A line with a particular keyword (default ",Object(i.b)("inlineCode",{parentName:"li"},"POP"),") must delimit populations"),Object(i.b)("li",{parentName:"ul"},"Sample name is immediately followed by a ",Object(i.b)("em",{parentName:"li"},"comma")),Object(i.b)("li",{parentName:"ul"},"File is ",Object(i.b)("em",{parentName:"li"},"tab or space delimted")," (but not both!)")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Genepop file example:")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"wasp_hive.gen: Wasp populations in New York \\n\nLocus1\nLocus2\nLocus3\npop\nOneida_01,  250230  564568  110100\nOneida_02,  252238  568558  100120\nOneida_03,  254230  564558  090100\npop\nNewcomb_01, 254230  564558  080100\nNewcomb_02, 000230  564558  090080\nNewcomb_03, 254230  000000  090100\nNewcomb_04, 254230  564000  090120\n")),Object(i.b)("p",null,":::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'waspsNY = genepop("wasp_hive.gen", digits = 3, popsep = "pop")\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("h2",{id:"ioutilsjl"},"ioUtils.jl"),Object(i.b)("p",null,":::: tabs\n::: tab ioUtils.jl/determine_marker"),Object(i.b)("h3",{id:"determine_marker"},Object(i.b)("inlineCode",{parentName:"h3"},"determine_marker")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"determine_marker(infile::String, geno_parse::CSV.File{}, digits::Int)\n")),Object(i.b)("p",null,"Return either ",Object(i.b)("inlineCode",{parentName:"p"},"Int8")," or ",Object(i.b)("inlineCode",{parentName:"p"},"Int16")," depending on largest allelic value in all genotypes in the first 10 samples of an input file (or all the samples if less than 10 samples). If the largest allele is 11 or greater, the marker will be considered a Microsatellite and coded in ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," as ",Object(i.b)("inlineCode",{parentName:"p"},"Int16"),", and the opposite is true for SNPs. There's no specific reason 10 was chosen other than it being a reasonable buffer for edge cases since SNP data <= 4, and haplotyped data could be a bit higher. Even if the microsatellite markers are coded incorrectly, there will be zero impact to performance, and considering how few microsatellite markers are used in typical studies, the effect on in-memory size should be negligible (as compared to SNPs).\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab ioUtils.jl/find_ploidy"),Object(i.b)("h3",{id:"find_ploidy"},Object(i.b)("inlineCode",{parentName:"h3"},"find_ploidy")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"find_ploidy(genotypes::T where T<:SubArray)\n")),Object(i.b)("p",null,"Used internally in the ",Object(i.b)("inlineCode",{parentName:"p"},"genepop")," and ",Object(i.b)("inlineCode",{parentName:"p"},"delimited")," file parsers to scan the genotypes of a sample and return the ploidy of the first non-missing locus.\n:::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab ioUtils.jl/phase"),Object(i.b)("h3",{id:"phase"},Object(i.b)("inlineCode",{parentName:"h3"},"phase")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"phase(loc::String, type::DataType, digit::Int)\n")),Object(i.b)("p",null,"Takes a String of numbers returns a typed locus appropriate for PopGen.jl as used in the ",Object(i.b)("inlineCode",{parentName:"p"},"genepop")," and ",Object(i.b)("inlineCode",{parentName:"p"},"csv")," file parsers. Use ",Object(i.b)("inlineCode",{parentName:"p"},"type")," to specify output type (",Object(i.b)("inlineCode",{parentName:"p"},"Int8")," or ",Object(i.b)("inlineCode",{parentName:"p"},"Int16"),"), and ",Object(i.b)("inlineCode",{parentName:"p"},"digit")," to specify the number of digits/characters used per allele in a locus.\n:::\n::: tab example"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'ph_locus = phase("128114", Int16, 3)\nmap(i -> phase(i, Int16, 3), ["112131", "211112", "001003", "516500"])\n# or #\n[phase(i, Int8, 2) for i in ["0101", "0103", "0202", "0103"]]\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("p",null,":::: tabs\n::: tab ioUtils.jl/phase_dip"),Object(i.b)("h3",{id:"phase_dip"},Object(i.b)("inlineCode",{parentName:"h3"},"phase_dip")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"phase_dip(loc::String, type::DataType, digit::Int)\nphase_dip(loc::T, type::DataType, digit::Int) where T<:Signed\nphase_dip(loc::Missing, type::DataType, digit::Int)\n")),Object(i.b)("p",null,"Diploid-optimized variants of ",Object(i.b)("inlineCode",{parentName:"p"},"phase()")," that use integer division to split the alleles of a locus into a tuple of ",Object(i.b)("inlineCode",{parentName:"p"},"type")," Type. Use ",Object(i.b)("inlineCode",{parentName:"p"},"type")," to specify output type (",Object(i.b)("inlineCode",{parentName:"p"},"Int8")," or ",Object(i.b)("inlineCode",{parentName:"p"},"Int16"),"), and ",Object(i.b)("inlineCode",{parentName:"p"},"digit")," to specify the number of digits/characters used per allele in a locus. The ",Object(i.b)("inlineCode",{parentName:"p"},"Missing")," method simply returns ",Object(i.b)("inlineCode",{parentName:"p"},"Missing"),".\n:::\n::: tab examples"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'ph_locus = phase("128114", Int16, 3)\nmap(i -> phase_dip(i, Int16, 3), ["112131", "211112", "001003", "516500"])\n# or #\n[phase_dip(i, Int8, 2) for i in ["0101", "0103", "0202", "0103"]]\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("h2",{id:"readjl"},"Read.jl"),Object(i.b)("p",null,":::: tabs\n::: tab Read.jl/read_in"),Object(i.b)("h3",{id:"read_in"},Object(i.b)("inlineCode",{parentName:"h3"},"read_in")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"read_in(infile::String; kwargs...)\n")),Object(i.b)("p",null,"Wraps ",Object(i.b)("inlineCode",{parentName:"p"},"delimited())"),", ",Object(i.b)("inlineCode",{parentName:"p"},"genepop()"),", ",Object(i.b)("inlineCode",{parentName:"p"},"bcf()"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"vcf()")," to read a file in as a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object. File type is inferred from the file extension (case insensitive):"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"delimited: ",Object(i.b)("inlineCode",{parentName:"li"},".csv")," | ",Object(i.b)("inlineCode",{parentName:"li"},".tsv")," | ",Object(i.b)("inlineCode",{parentName:"li"},".txt")),Object(i.b)("li",{parentName:"ul"},"genepop: ",Object(i.b)("inlineCode",{parentName:"li"},".gen")," | ",Object(i.b)("inlineCode",{parentName:"li"},".genepop")),Object(i.b)("li",{parentName:"ul"},"variant call format: ",Object(i.b)("inlineCode",{parentName:"li"},".vcf")," | ",Object(i.b)("inlineCode",{parentName:"li"},".bcf"),"\nThis function uses the same keyword arguments (and defaults) as the file importing functions it wraps; please see their respective docstrings in the Julia help console. (e.g. ",Object(i.b)("inlineCode",{parentName:"li"},"?genepop"),") for specific usage details. Use the alias function ",Object(i.b)("inlineCode",{parentName:"li"},"file_import")," interchangeably if you prefer the explicit name instead.\n:::\n::: tab example")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'read_in("cavernous_assfish.gen", digits = 3)\nfile_import("bos_tauros.csv", silent = true)\nread_in("juglans_nigra.vcf")\n')),Object(i.b)("p",null,":::\n::::"),Object(i.b)("h2",{id:"variantcalljl"},"VariantCall.jl"),Object(i.b)("p",null,":::: tabs\n::: tab Variantcall.jl/bcf"),Object(i.b)("h3",{id:"bcf"},Object(i.b)("inlineCode",{parentName:"h3"},"bcf")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"bcf(infile::String)\n")),Object(i.b)("p",null,"Load a BCF file into memory as a PopData object. Population and ","[optional]"," location information need to be provided separately."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"infile")," : path to BCF file\n:::\n::::")),Object(i.b)("p",null,":::: tabs\n::: tab VariantCall.jl/vcf"),Object(i.b)("h3",{id:"vcf"},Object(i.b)("inlineCode",{parentName:"h3"},"vcf")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"vcf(infile::String)\n")),Object(i.b)("p",null,"Load a VCF file into memory as a PoDataj object. Population and ","[optional]"," location information need to be provided separately."),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"infile")," : path to VCF file\n:::\n::::")))}r.isMDXComponent=!0},150:function(e,a,t){"use strict";t.d(a,"a",(function(){return s})),t.d(a,"b",(function(){return j}));var n=t(0),l=t.n(n);function i(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function b(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){i(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function c(e,a){if(null==e)return{};var t,n,l=function(e,a){if(null==e)return{};var t,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(l[t]=e[t]);return l}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var p=l.a.createContext({}),r=function(e){var a=l.a.useContext(p),t=a;return e&&(t="function"==typeof e?e(a):b(b({},a),e)),t},s=function(e){var a=r(e.components);return l.a.createElement(p.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return l.a.createElement(l.a.Fragment,{},a)}},u=l.a.forwardRef((function(e,a){var t=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),s=r(t),u=n,j=s["".concat(o,".").concat(u)]||s[u]||d[u]||i;return t?l.a.createElement(j,b(b({ref:a},p),{},{components:t})):l.a.createElement(j,b({ref:a},p))}));function j(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var i=t.length,o=new Array(i);o[0]=u;var b={};for(var c in a)hasOwnProperty.call(a,c)&&(b[c]=a[c]);b.originalType=e,b.mdxType="string"==typeof e?e:n,o[1]=b;for(var p=2;p<i;p++)o[p]=t[p];return l.a.createElement.apply(null,o)}return l.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"}}]);