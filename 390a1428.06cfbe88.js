(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{119:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return r})),a.d(t,"metadata",(function(){return l})),a.d(t,"rightToc",(function(){return c})),a.d(t,"default",(function(){return b}));var n=a(2),o=a(6),i=(a(0),a(165)),r={},l={id:"popobj_type",title:"popobj_type",description:"PopObj and PopData types",source:"@site/docs/popobj_type.md",permalink:"/PopGen.jl/docs/popobj_type",editUrl:"https://github.com/pdimens/popgen.jl/edit/documentation/docs/popobj_type.md"},c=[{value:"Metadata",id:"metadata",children:[{value:"name",id:"name",children:[]},{value:"population",id:"population",children:[]},{value:"ploidy",id:"ploidy",children:[]},{value:"longitude",id:"longitude",children:[]},{value:"latitude",id:"latitude",children:[]}]},{value:"Genotype Information",id:"genotype-information",children:[{value:"name",id:"name-1",children:[]},{value:"population",id:"population-1",children:[]},{value:"locus",id:"locus",children:[]},{value:"genotype",id:"genotype",children:[]}]},{value:"Viewing PopData",id:"viewing-popdata",children:[]},{value:"location data",id:"location-data",children:[]}],p={rightToc:c};function b(e){var t=e.components,a=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},p,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"popobj-and-popdata-types"},"PopObj and PopData types"),Object(i.b)("p",null,"For the PopGen.jl package to be consistent, a standard flexible data structure needs to be defined. The solution is a custom type called  ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),". The struct is defined as:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"struct PopData\n    meta::DataFrame\n    loci::DataFrame\nend\n")),Object(i.b)("p",null,"As you can see, a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," is made up of two DataFrames (from ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/JuliaData/DataFrames.jl"}),"DataFrames.jl"),"), one called ",Object(i.b)("inlineCode",{parentName:"p"},"meta")," for sample information (metadata), and the other called ",Object(i.b)("inlineCode",{parentName:"p"},"loci")," which includes genotype information. This structure allows for easy and convenient access to the fields using dot ",Object(i.b)("inlineCode",{parentName:"p"},".")," accessors.. The ",Object(i.b)("inlineCode",{parentName:"p"},"meta")," and ",Object(i.b)("inlineCode",{parentName:"p"},"loci")," tables are both specific in their structure, so here is an illustration to help you visualize a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," object:"),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"/PopGen.jl/images/PopData.svg",alt:"PopData"}))),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"PopData")," and other custom types introduced in PopGen.jl fall under an AbstractType we call ",Object(i.b)("inlineCode",{parentName:"p"},"PopObj"),', which is short for "PopGen Object".'),Object(i.b)("p",null,'::: details pronouncing "PopObj"\nIt\'s not super obvious, but we decided to pronounce PopObj as "pop ob" with a silent j because it sounds better than saying "pop obj", but writing it as PopOb looks weird. It\'s a silly little detail that Pavel seems to care a lot about.\n:::'),Object(i.b)("p",null,"::: danger avoid manual creation!\nWhile it may seem simple enough to create two IndexedTables and make a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," out of them, the structure of ",Object(i.b)("inlineCode",{parentName:"p"},"meta")," and ",Object(i.b)("inlineCode",{parentName:"p"},"loci")," are specific, so small mistakes in creating them can create many errors and prevent PopGen from working correctly on your data. Please use the included ",Object(i.b)("inlineCode",{parentName:"p"},"csv"),", ",Object(i.b)("inlineCode",{parentName:"p"},"genepop"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"vcf")," file importers instead.\n:::"),Object(i.b)("h2",{id:"metadata"},"Metadata"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"meta")," table has 5 specific categories/columns: name, population, ploidy, longitude, latitude. These can be directly accessed with ",Object(i.b)("inlineCode",{parentName:"p"},"PopData.meta.colname")," where ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," is the name of your PopData object, and ",Object(i.b)("inlineCode",{parentName:"p"},"colname")," is one of the five column names below."),Object(i.b)("h3",{id:"name"},"name"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"::Vector{String}")),Object(i.b)("p",null,"The individual/sample names"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'["ind_001", "ind_002", "ind_003"]\n')),Object(i.b)("h3",{id:"population"},"population"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"::Vector{String}")),Object(i.b)("p",null,"The individual/sample population ID's"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),'["borneo", "borneo", "new jersey"]\n')),Object(i.b)("h3",{id:"ploidy"},"ploidy"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"::Vector{Int8}")),Object(i.b)("p",null,"The ploidy of the samples"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia"}),"[2, 2, 2]\n")),Object(i.b)("h3",{id:"longitude"},"longitude"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"::Vector{Union{Missing,Float32}}")),Object(i.b)("p",null,"latitude data of samples (decimal degrees)"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"[-11.12, 15.32, 11.02, -4.42]\n")),Object(i.b)("h3",{id:"latitude"},"latitude"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"::Vector{Union{Missing,Float64}}")),Object(i.b)("p",null,"longitude data of samples (decimal degrees)"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"[-11.12, 15.32, 11.02, -4]\n")),Object(i.b)("h2",{id:"genotype-information"},"Genotype Information"),Object(i.b)("p",null,"The genotype information is stored in a separate table called ",Object(i.b)("inlineCode",{parentName:"p"},"loci"),'. This table is rather special in that it is stored in "tidy" format, i.e. one record per row. Storing data this way makes it a lot easier to interrogate the data and write new functions, along with leveraging ',Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/JuliaData/DataFrames.jl"}),"DataFramesMeta.jl")," and ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/queryverse/Query.jl"}),"Query.jl"),". It also means the table will have as many rows as loci x samples, which can become a lot. To reduce redundant objects inflating object size, the columns name, population, and locus are ",Object(i.b)("inlineCode",{parentName:"p"},"Categorical"),"  from ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/JuliaData/CategoricalArrays.jl"}),"CategoricalArrays.jl"),", which is a memory-saving data structure for long repetitive categorical data. Without using this format, ",Object(i.b)("inlineCode",{parentName:"p"},"gulfsharks"),", whose source file is 3.2mb, would occupy about 27mb in your RAM! The classes of ",Object(i.b)("inlineCode",{parentName:"p"},".loci")," can be directly accessed with ",Object(i.b)("inlineCode",{parentName:"p"},"PopData.loci.colname")," where ",Object(i.b)("inlineCode",{parentName:"p"},"PopData")," is the name of your PopData object, and ",Object(i.b)("inlineCode",{parentName:"p"},"colname")," is one of the four column names below."),Object(i.b)("h3",{id:"name-1"},"name"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"::Vector{Categorical}")),Object(i.b)("p",null,"The sample name, stored as a ",Object(i.b)("inlineCode",{parentName:"p"},"CategoricalString"),". Fundamentally, this acts like the ",Object(i.b)("inlineCode",{parentName:"p"},"name")," column of the ",Object(i.b)("inlineCode",{parentName:"p"},"meta")," table, except when deleting entries and a few uncommon edge cases."),Object(i.b)("h3",{id:"population-1"},"population"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"::Vector{Categorical}")),Object(i.b)("p",null,"The population ID associated with that sample, stored as a ",Object(i.b)("inlineCode",{parentName:"p"},"CategoricalString"),". Fundamentally, this acts like the ",Object(i.b)("inlineCode",{parentName:"p"},"population")," column of the ",Object(i.b)("inlineCode",{parentName:"p"},"meta")," table, except when deleting entries and a few uncommon edge cases."),Object(i.b)("h3",{id:"locus"},"locus"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"::Vector{Categorical}")),Object(i.b)("p",null,"The locus associated with the genotype, stored as a ",Object(i.b)("inlineCode",{parentName:"p"},"CategoricalString"),"."),Object(i.b)("h3",{id:"genotype"},"genotype"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"::Vector{Union{Missing,Genotype}}")),Object(i.b)("p",null,"The genotypes of the ",Object(i.b)("inlineCode",{parentName:"p"},"loci")," are an array of type ",Object(i.b)("inlineCode",{parentName:"p"},"Genotype"),", which is an alias for a built-in Julia Tuple type with each value corresponding to an allele (read below to disentangle what that type actually is). For the most part, it looks like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-julia",metastring:'tab="genotype example"',tab:'"genotype','example"':!0}),"[(0,1), (0,0), missing, (1,2)]\n")),Object(i.b)("p",null,"::: warning immutable genotypes\nWe use the Tuple type for genotypes of individuals because they are ",Object(i.b)("strong",{parentName:"p"},"immutable")," (cannot be changed). By the time you're using PopGen.jl, your data should already be filtered and screened. Hand-editing of genotype alleles is ",Object(i.b)("strong",{parentName:"p"},"strongly")," discouraged, so we outlawed it.\n:::"),Object(i.b)("h2",{id:"viewing-popdata"},"Viewing PopData"),Object(i.b)("p",null,"Given the volume of information that can be present in a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),", we overload ",Object(i.b)("inlineCode",{parentName:"p"},"Base.show")," to summarize/overview the data rather than regurgitate everything on the screen. "),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{}),"julia> a = gulfsharks() ;\nPopData Object\n  Marker type: SNP\n  Ploidy: 2\n  Number of individuals: 212\n  Number of loci: 2213\n  Populations: 7\n  Longitude: present with 0 missing\n  Latitude: present with 0 missing\n")),Object(i.b)("h2",{id:"location-data"},"location data"),Object(i.b)("p",null,"Location data is optional for a ",Object(i.b)("inlineCode",{parentName:"p"},"PopData"),". There are functions that use location information (e.g. ",Object(i.b)("inlineCode",{parentName:"p"},"locations"),"), but most don't, so it's not a dealbreaker. At present, there are no analyses that utilize location information. "))}b.isMDXComponent=!0},165:function(e,t,a){"use strict";a.d(t,"a",(function(){return s})),a.d(t,"b",(function(){return m}));var n=a(0),o=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var p=o.a.createContext({}),b=function(e){var t=o.a.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},s=function(e){var t=b(e.components);return o.a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},u=o.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,r=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),s=b(a),u=n,m=s["".concat(r,".").concat(u)]||s[u]||d[u]||i;return a?o.a.createElement(m,l(l({ref:t},p),{},{components:a})):o.a.createElement(m,l({ref:t},p))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,r=new Array(i);r[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:n,r[1]=l;for(var p=2;p<i;p++)r[p]=a[p];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);